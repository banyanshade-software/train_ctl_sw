
#


%prefix "cnfparse"

%value "config_node_t *"
%auxil "system_t *"

%header {
#include <stdio.h>
#include <stdlib.h>
#include "system.h"

}

%source{
#define PCC_ERROR(auxil) system__handle_syntax_error(auxil, SYNTAX_ERROR_UNKNOWN, range__void()) /* <-- caused by incompleteness of the grammar */
#define PCC_GETCHAR(auxil) system__read_source_file(auxil)
#define PCC_MALLOC(auxil, size) system__allocate_memory(auxil, size)
#define PCC_REALLOC(auxil, ptr, size) system__reallocate_memory(auxil, ptr, size)
#define PCC_FREE(auxil, ptr) system__deallocate_memory(auxil, ptr)
 
static const char *dbg_str[] = { "EVAL_", "MATCH", "ABAND" };

#define PCC_DEBUG(auxil, event, rule, level, pos, buffer, length) do {\
	 if ((0)) fprintf(stdout, "%*s%s %s @%d [%.*s]\n", (int)(level * 2), "", dbg_str[event], rule, (int)pos, (int)length,  buffer); fflush(stdout); \
} while(0)


}


confall 
	<- _ s:configdef _ l:confall
	    {
            $$ = s;
            $$->range = range__new($0s, $0e);
			$$->next = l;
	    }
     / _ s:configdef 
        {
            $$ = s;
        }
	 / _ end_of_file

configdef
	<- kw_config _ n:identifier _  f:fields  _ kw_num _ board_values  _ ';' 
        {
            $$ = create_config_node(auxil, CONFIG_NODE_CONF, range__new($0s, $0e));
            $$->string = n->string;
            $$->fields = f;
        }


fields
	<- '{' _ l:field_list _ '}'
		{ $$ = l; }

field_list 
	<-  f:field _ l:field_list
     	{ 
			if (l) {
				$$ = l;
				config_node_append(l, f);
			} else {
				$$ = f;
			}
		}
	 /  f:field
		{ $$ = f; }

field 
	<- q:qualifier _ type _ d:fielddef _ board_values _ ';'
		{
			$$ =  create_config_node(auxil, CONFIG_NODE_FIELD, range__new($0s, $0e));
			$$->string = d->string;
			$$->array = d->array;
			$$->bitfield = d->bitfield;
			$$->configurable = q->value;
		}

fielddef 
	<- i:identifier _ '[' n:integer ']'
		{ $$ = i; $$->array = n->value; }
     / i:identifier _ ':' n:integer
		{ $$ = i; $$->bitfield = n->value; }
     / i:identifier
		{ $$ = i; }

type
	<- identifier _ ('*')+
     / identifier

qualifier
	<- kw_const
		{ $$ = create_config_node_int(auxil, CONFIG_NODE_IDENT, range__new($0s, $0e), 0);}
     / kw_user
		{ $$ = create_config_node_int(auxil, CONFIG_NODE_IDENT, range__new($0s, $0e), 1);}

board_values 
	<- board_val _ board_values
        / board_val

board_val 
	<- '=' _ '(' board_id  ')' _ value

board_id 
	<- kw_all
         / identifier ':' D+
         / identifier

value
	<- integer
     / identifier
     / '{' _ val_list _ '}'

val_list 
	<- value _ ',' _ val_list
	 / value



# ########################################@

integer
   <- '0'[xX]X+
    {
        $$ = create_config_node_intstr(auxil, CONFIG_NODE_INT, range__new($0s, $0e), 16);
    }
    / '0'O+
    {
        $$ = create_config_node_intstr(auxil, CONFIG_NODE_INT, range__new($0s, $0e), 8);
    }
    / !'0' D+
    {
        $$ = create_config_node_intstr(auxil, CONFIG_NODE_INT, range__new($0s, $0e), 10);
    }
    / D !D


kw_config <- 'config'  !(L/D)
kw_num    <- 'num' !(L/D)
kw_const  <- 'const' !(L/D)
kw_user <- 'user' !(L/D)
kw_all  <- 'all' !(L/D)

O <- [0-7]
D <- [0-9]
X <- [0-9a-fA-F]
L <- [a-zA-Z_]


keyword
   <- kw_num
    / kw_const
    / kw_user
    / kw_all
    / kw_config

_ <- ( space / comment )*
#_ <- ( comment / space )*

comment
   <- '/*' ( !'*/' . )* '*/'
    / '#' (!end_of_line .)* end_of_line
    / '//' (!end_of_line .)* end_of_line
    ## error handling ##
    / '/*' ( !'*/' . )*
    {
	fprintf(stderr, "unclosed comment at %ld-%ld", $0s, $0e);
        //system__handle_syntax_error(auxil, SYNTAX_ERROR_UNCLOSED_COMMENT_BLOCK, range__new($0s, $0e));
    }


space <- blank / end_of_line
blank <- [ \t\v\f]
end_of_line <- '\r\n' / '\n' / '\r'
end_of_file <- !.

	
identifier
   <- !keyword L(L/D)*
    {
        $$ = create_config_node_text(auxil, CONFIG_NODE_IDENT, range__new($0s, $0e));
    }


%%

